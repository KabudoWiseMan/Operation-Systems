Лабораторная работа №4

------------------------------------ReactOS----------------------------------------

1. Создать новый драйвер так же, как во второй лабораторной работе;

2. В файле драйвера подключить библиотеки "ntifs", "ndk/ntndk" и "windef";

3. В виртуальном адресном пространстве PTE расположены, начиная с адреса 0xс0000000, поэтому создадим переменную PTE_BASE с таким значением. Каждая страница имеет размер 4096 байт, нам нужно зарезервировать 10 страниц и обеспечить первые 5 из них физическими страницами памяти, поэтому создадим переменную Pages типа PVOID, куда будет записан виртуальный адрес первой страницы, и получим Status с помощью функции ZwAllocateVirtualMemory(NtCurrentProcess(), MEM_RESERVE, …) размера 4096 * 10, зарезервируя тем самым 10 страниц. Если Status не STATUS_SUCCESS, то выводим ошибку, в ином случае обеспечиваем первые 5 из них физическими страницами с помощью функции ZwAllocateVirtualMemory(NtCurrentProcess(), MEM_COMMIT, …) размера 4096 * 5 и снова проверяем Status. Если всё прошло успешно, то запишем в начале каждого PTE, начиная с Pages, какие-нибудь значения, чтобы проверить, что память успешно выделена. После чего можно получить каждый PTE, разделив виртуальный адрес на 4096 и прибавив к нему PTE_BASE и номер каждой страницы. Поэтому, запускаем цикл, в котором получаем PTE и выводим физический адрес с помощью обращения к pte->PageFrameNumber и умножения его на 0x1000 (4096 байт) и другие значения PTE, обращаясь к pte->Valid, pte->WriteThrough, pte->CacheDisable, pte->Accessed, pte->Dirty, pte->LargePage, pte->Global, pte->CopyOnWrite, pte->Prototype, pte->PageFrameNumber. После этого освобождаем память, вызывая функцию ZwFreeVirtualMemory.

4. Запускаем ReactOS и новый драйвер, как во второй лабораторной работе.

-------------------------------------NetBSD----------------------------------------

1. Создать новый драйвер так же, как во второй лабораторной работе;

2. В файле драйвера подключить библиотеку "sys/cdefs", "sys/param", "sys/sysctl", "uvm/uvm";

3. Принцип тот же, что и в ReactOS. Создаём переменные va типа vaddr_t и plist типа struct pglist. Получаем va, резервируя 10 страниц с помощью функции uvm_km_alloc, если va = 0, то выводим ошибку, в ином случае обеспечиваем 5 первых страниц физическими страницами памяти с помощью функции uvm_pglistalloc, передавая ей адрес нашей переменной plist, проверяем снова на наличие ошибок. Создаём указатель page типа struct vm_page и присваиваем ему TAILQ_FIRST(&plist). Запускаем цикл, получаем физический адрес с помощью функции VM_PAGE_TO_PHYS, потом создаём указатель ppte типа pd_entry_t и кладём туда PTE, прибавляя к L2_BASE pl2_i(va + 0x1000 * i), после чего выводим физический адрес, полученный нами ранее, и значения PTE, перемножая логически *ppte с PG_V, PG_WT, PG_N, PG_U, PG_M и смотря, получился ли 0 или нет, затем переходим к следующей странице с помощью функции TAILQ_NEXT. После цикла освобождаем памят с помощью функций uvm_pglistfree и uvm_km_free.

4. Запустить драйвер, как во второй лабораторной работе.